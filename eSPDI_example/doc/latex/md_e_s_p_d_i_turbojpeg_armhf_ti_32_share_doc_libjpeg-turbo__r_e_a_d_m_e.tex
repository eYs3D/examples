libjpeg-\/turbo is a J\+P\+EG image codec that uses S\+I\+MD instructions to accelerate baseline J\+P\+EG compression and decompression on x86, x86-\/64, A\+RM, Power\+PC, and M\+I\+PS systems, as well as progressive J\+P\+EG compression on x86 and x86-\/64 systems. On such systems, libjpeg-\/turbo is generally 2-\/6x as fast as libjpeg, all else being equal. On other types of systems, libjpeg-\/turbo can still outperform libjpeg by a significant amount, by virtue of its highly-\/optimized Huffman coding routines. In many cases, the performance of libjpeg-\/turbo rivals that of proprietary high-\/speed J\+P\+EG codecs.

libjpeg-\/turbo implements both the traditional libjpeg A\+PI as well as the less powerful but more straightforward Turbo\+J\+P\+EG A\+PI. libjpeg-\/turbo also features colorspace extensions that allow it to compress from/decompress to 32-\/bit and big-\/endian pixel buffers (R\+G\+BX, X\+B\+GR, etc.), as well as a full-\/featured Java interface.

libjpeg-\/turbo was originally based on libjpeg/\+S\+I\+MD, an M\+M\+X-\/accelerated derivative of libjpeg v6b developed by Miyasaka Masaru. The Tiger\+V\+NC and Virtual\+GL projects made numerous enhancements to the codec in 2009, and in early 2010, libjpeg-\/turbo spun off into an independent project, with the goal of making high-\/speed J\+P\+EG compression/decompression technology available to a broader range of users and developers.

\section*{License }

libjpeg-\/turbo is covered by three compatible B\+S\+D-\/style open source licenses. Refer to L\+I\+C\+E\+N\+SE.md for a roll-\/up of license terms.

\section*{Building libjpeg-\/turbo }

Refer to B\+U\+I\+L\+D\+I\+NG.md for complete instructions.

\section*{Using libjpeg-\/turbo }

libjpeg-\/turbo includes two A\+P\+Is that can be used to compress and decompress J\+P\+EG images\+:


\begin{DoxyItemize}
\item {\bfseries Turbo\+J\+P\+EG A\+PI}~\newline
 This A\+PI provides an easy-\/to-\/use interface for compressing and decompressing J\+P\+EG images in memory. It also provides some functionality that would not be straightforward to achieve using the underlying libjpeg A\+PI, such as generating planar Y\+UV images and performing multiple simultaneous lossless transforms on an image. The Java interface for libjpeg-\/turbo is written on top of the Turbo\+J\+P\+EG A\+PI. The Turbo\+J\+P\+EG A\+PI is recommended for first-\/time users of libjpeg-\/turbo. Refer to \href{tjexample.c}{\tt tjexample.\+c} and \href{java/TJExample.java}{\tt T\+J\+Example.\+java} for examples of its usage and to \href{http://libjpeg-turbo.org/Documentation/Documentation}{\tt http\+://libjpeg-\/turbo.\+org/\+Documentation/\+Documentation} for A\+PI documentation.
\item {\bfseries libjpeg A\+PI}~\newline
 This is the de facto industry-\/standard A\+PI for compressing and decompressing J\+P\+EG images. It is more difficult to use than the Turbo\+J\+P\+EG A\+PI but also more powerful. The libjpeg A\+PI implementation in libjpeg-\/turbo is both A\+P\+I/\+A\+B\+I-\/compatible and mathematically compatible with libjpeg v6b. It can also optionally be configured to be A\+P\+I/\+A\+B\+I-\/compatible with libjpeg v7 and v8 (see below.) Refer to \href{cjpeg.c}{\tt cjpeg.\+c} and \href{djpeg.c}{\tt djpeg.\+c} for examples of its usage and to \href{libjpeg.txt}{\tt libjpeg.\+txt} for A\+PI documentation.
\end{DoxyItemize}

There is no significant performance advantage to either A\+PI when both are used to perform similar operations.

\subsection*{Colorspace Extensions }

libjpeg-\/turbo includes extensions that allow J\+P\+EG images to be compressed directly from (and decompressed directly to) buffers that use B\+GR, B\+G\+RX, R\+G\+BX, X\+B\+GR, and X\+R\+GB pixel ordering. This is implemented with ten new colorspace constants\+: \begin{DoxyVerb}JCS_EXT_RGB   /* red/green/blue */
JCS_EXT_RGBX  /* red/green/blue/x */
JCS_EXT_BGR   /* blue/green/red */
JCS_EXT_BGRX  /* blue/green/red/x */
JCS_EXT_XBGR  /* x/blue/green/red */
JCS_EXT_XRGB  /* x/red/green/blue */
JCS_EXT_RGBA  /* red/green/blue/alpha */
JCS_EXT_BGRA  /* blue/green/red/alpha */
JCS_EXT_ABGR  /* alpha/blue/green/red */
JCS_EXT_ARGB  /* alpha/red/green/blue */
\end{DoxyVerb}


Setting {\ttfamily cinfo.\+in\+\_\+color\+\_\+space} (compression) or {\ttfamily cinfo.\+out\+\_\+color\+\_\+space} (decompression) to one of these values will cause libjpeg-\/turbo to read the red, green, and blue values from (or write them to) the appropriate position in the pixel when compressing from/decompressing to an R\+GB buffer.

Your application can check for the existence of these extensions at compile time with\+: \begin{DoxyVerb}#ifdef JCS_EXTENSIONS
\end{DoxyVerb}


At run time, attempting to use these extensions with a libjpeg implementation that does not support them will result in a \char`\"{}\+Bogus input colorspace\char`\"{} error. Applications can trap this error in order to test whether run-\/time support is available for the colorspace extensions.

When using the R\+G\+BX, B\+G\+RX, X\+B\+GR, and X\+R\+GB colorspaces during decompression, the X byte is undefined, and in order to ensure the best performance, libjpeg-\/turbo can set that byte to whatever value it wishes. If an application expects the X byte to be used as an alpha channel, then it should specify {\ttfamily J\+C\+S\+\_\+\+E\+X\+T\+\_\+\+R\+G\+BA}, {\ttfamily J\+C\+S\+\_\+\+E\+X\+T\+\_\+\+B\+G\+RA}, {\ttfamily J\+C\+S\+\_\+\+E\+X\+T\+\_\+\+A\+B\+GR}, or {\ttfamily J\+C\+S\+\_\+\+E\+X\+T\+\_\+\+A\+R\+GB}. When these colorspace constants are used, the X byte is guaranteed to be 0x\+FF, which is interpreted as opaque.

Your application can check for the existence of the alpha channel colorspace extensions at compile time with\+: \begin{DoxyVerb}#ifdef JCS_ALPHA_EXTENSIONS
\end{DoxyVerb}


\href{jcstest.c}{\tt jcstest.\+c}, located in the libjpeg-\/turbo source tree, demonstrates how to check for the existence of the colorspace extensions at compile time and run time.

\subsection*{libjpeg v7 and v8 A\+P\+I/\+A\+BI Emulation }

With libjpeg v7 and v8, new features were added that necessitated extending the compression and decompression structures. Unfortunately, due to the exposed nature of those structures, extending them also necessitated breaking backward A\+BI compatibility with previous libjpeg releases. Thus, programs that were built to use libjpeg v7 or v8 did not work with libjpeg-\/turbo, since it is based on the libjpeg v6b code base. Although libjpeg v7 and v8 are not as widely used as v6b, enough programs (including a few Linux distros) made the switch that there was a demand to emulate the libjpeg v7 and v8 A\+B\+Is in libjpeg-\/turbo. It should be noted, however, that this feature was added primarily so that applications that had already been compiled to use libjpeg v7+ could take advantage of accelerated baseline J\+P\+EG encoding/decoding without recompiling. libjpeg-\/turbo does not claim to support all of the libjpeg v7+ features, nor to produce identical output to libjpeg v7+ in all cases (see below.)

By passing an argument of {\ttfamily -\/\+D\+W\+I\+T\+H\+\_\+\+J\+P\+E\+G7=1} or {\ttfamily -\/\+D\+W\+I\+T\+H\+\_\+\+J\+P\+E\+G8=1} to {\ttfamily cmake}, you can build a version of libjpeg-\/turbo that emulates the libjpeg v7 or v8 A\+BI, so that programs that are built against libjpeg v7 or v8 can be run with libjpeg-\/turbo. The following section describes which libjpeg v7+ features are supported and which aren\textquotesingle{}t.

\subsubsection*{Support for libjpeg v7 and v8 Features}

\paragraph*{Fully supported}


\begin{DoxyItemize}
\item {\bfseries libjpeg A\+PI\+: I\+D\+CT scaling extensions in decompressor}~\newline
 libjpeg-\/turbo supports I\+D\+CT scaling with scaling factors of 1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8, 9/8, 5/4, 11/8, 3/2, 13/8, 7/4, 15/8, and 2/1 (only 1/4 and 1/2 are S\+I\+M\+D-\/accelerated.)
\item {\bfseries libjpeg A\+PI\+: Arithmetic coding}
\item {\bfseries libjpeg A\+PI\+: In-\/memory source and destination managers}~\newline
 See notes below.
\item {\bfseries cjpeg\+: Separate quality settings for luminance and chrominance}~\newline
 Note that the libpjeg v7+ A\+PI was extended to accommodate this feature only for convenience purposes. It has always been possible to implement this feature with libjpeg v6b (see rdswitch.\+c for an example.)
\item {\bfseries cjpeg\+: 32-\/bit B\+MP support}
\item {\bfseries cjpeg\+: {\ttfamily -\/rgb} option}
\item {\bfseries jpegtran\+: Lossless cropping}
\item {\bfseries jpegtran\+: {\ttfamily -\/perfect} option}
\item {\bfseries jpegtran\+: Forcing width/height when performing lossless crop}
\item {\bfseries rdjpgcom\+: {\ttfamily -\/raw} option}
\item {\bfseries rdjpgcom\+: Locale awareness}
\end{DoxyItemize}

\paragraph*{Not supported}

N\+O\+TE\+: As of this writing, extensive research has been conducted into the usefulness of D\+CT scaling as a means of data reduction and Smart\+Scale as a means of quality improvement. The reader is invited to peruse the research at \href{http://www.libjpeg-turbo.org/About/SmartScale}{\tt http\+://www.\+libjpeg-\/turbo.\+org/\+About/\+Smart\+Scale} and draw his/her own conclusions, but it is the general belief of our project that these features have not demonstrated sufficient usefulness to justify inclusion in libjpeg-\/turbo.


\begin{DoxyItemize}
\item {\bfseries libjpeg A\+PI\+: D\+CT scaling in compressor}~\newline
 {\ttfamily cinfo.\+scale\+\_\+num} and {\ttfamily cinfo.\+scale\+\_\+denom} are silently ignored. There is no technical reason why D\+CT scaling could not be supported when emulating the libjpeg v7+ A\+P\+I/\+A\+BI, but without the Smart\+Scale extension (see below), only scaling factors of 1/2, 8/15, 4/7, 8/13, 2/3, 8/11, 4/5, and 8/9 would be available, which is of limited usefulness.
\item {\bfseries libjpeg A\+PI\+: Smart\+Scale}~\newline
 {\ttfamily cinfo.\+block\+\_\+size} is silently ignored. Smart\+Scale is an extension to the J\+P\+EG format that allows for D\+CT block sizes other than 8x8. Providing support for this new format would be feasible (particularly without full acceleration.) However, until/unless the format becomes either an official industry standard or, at minimum, an accepted solution in the community, we are hesitant to implement it, as there is no sense of whether or how it might change in the future. It is our belief that Smart\+Scale has not demonstrated sufficient usefulness as a lossless format nor as a means of quality enhancement, and thus our primary interest in providing this feature would be as a means of supporting additional D\+CT scaling factors.
\item {\bfseries libjpeg A\+PI\+: Fancy downsampling in compressor}~\newline
 {\ttfamily cinfo.\+do\+\_\+fancy\+\_\+downsampling} is silently ignored. This requires the D\+CT scaling feature, which is not supported.
\item {\bfseries jpegtran\+: Scaling}~\newline
 This requires both the D\+CT scaling and Smart\+Scale features, which are not supported.
\item {\bfseries Lossless R\+GB J\+P\+EG files}~\newline
 This requires the Smart\+Scale feature, which is not supported.
\end{DoxyItemize}

\subsubsection*{What About libjpeg v9?}

libjpeg v9 introduced yet another field to the J\+P\+EG compression structure ({\ttfamily color\+\_\+transform}), thus making the A\+BI backward incompatible with that of libjpeg v8. This new field was introduced solely for the purpose of supporting lossless Smart\+Scale encoding. Furthermore, there was actually no reason to extend the A\+PI in this manner, as the color transform could have just as easily been activated by way of a new J\+P\+EG colorspace constant, thus preserving backward A\+BI compatibility.

Our research (see link above) has shown that lossless Smart\+Scale does not generally accomplish anything that can\textquotesingle{}t already be accomplished better with existing, standard lossless formats. Therefore, at this time it is our belief that there is not sufficient technical justification for software projects to upgrade from libjpeg v8 to libjpeg v9, and thus there is not sufficient technical justification for us to emulate the libjpeg v9 A\+BI.

\subsection*{In-\/\+Memory Source/\+Destination Managers }

By default, libjpeg-\/turbo 1.\+3 and later includes the {\ttfamily jpeg\+\_\+mem\+\_\+src()} and {\ttfamily jpeg\+\_\+mem\+\_\+dest()} functions, even when not emulating the libjpeg v8 A\+P\+I/\+A\+BI. Previously, it was necessary to build libjpeg-\/turbo from source with libjpeg v8 A\+P\+I/\+A\+BI emulation in order to use the in-\/memory source/destination managers, but several projects requested that those functions be included when emulating the libjpeg v6b A\+P\+I/\+A\+BI as well. This allows the use of those functions by programs that need them, without breaking A\+BI compatibility for programs that don\textquotesingle{}t, and it allows those functions to be provided in the \char`\"{}official\char`\"{} libjpeg-\/turbo binaries.

Those who are concerned about maintaining strict conformance with the libjpeg v6b or v7 A\+PI can pass an argument of {\ttfamily -\/\+D\+W\+I\+T\+H\+\_\+\+M\+E\+M\+\_\+\+S\+R\+C\+D\+ST=0} to {\ttfamily cmake} prior to building libjpeg-\/turbo. This will restore the pre-\/1.\+3 behavior, in which {\ttfamily jpeg\+\_\+mem\+\_\+src()} and {\ttfamily jpeg\+\_\+mem\+\_\+dest()} are only included when emulating the libjpeg v8 A\+P\+I/\+A\+BI.

On Un$\ast$x systems, including the in-\/memory source/destination managers changes the dynamic library version from 62.\+2.\+0 to 62.\+3.\+0 if using libjpeg v6b A\+P\+I/\+A\+BI emulation and from 7.\+2.\+0 to 7.\+3.\+0 if using libjpeg v7 A\+P\+I/\+A\+BI emulation.

Note that, on most Un$\ast$x systems, the dynamic linker will not look for a function in a library until that function is actually used. Thus, if a program is built against libjpeg-\/turbo 1.\+3+ and uses {\ttfamily jpeg\+\_\+mem\+\_\+src()} or {\ttfamily jpeg\+\_\+mem\+\_\+dest()}, that program will not fail if run against an older version of libjpeg-\/turbo or against libjpeg v7-\/ until the program actually tries to call {\ttfamily jpeg\+\_\+mem\+\_\+src()} or {\ttfamily jpeg\+\_\+mem\+\_\+dest()}. Such is not the case on Windows. If a program is built against the libjpeg-\/turbo 1.\+3+ D\+LL and uses {\ttfamily jpeg\+\_\+mem\+\_\+src()} or {\ttfamily jpeg\+\_\+mem\+\_\+dest()}, then it must use the libjpeg-\/turbo 1.\+3+ D\+LL at run time.

Both cjpeg and djpeg have been extended to allow testing the in-\/memory source/destination manager functions. See their respective man pages for more details.

\section*{Mathematical Compatibility }

For the most part, libjpeg-\/turbo should produce identical output to libjpeg v6b. The one exception to this is when using the floating point D\+C\+T/\+I\+D\+CT, in which case the outputs of libjpeg v6b and libjpeg-\/turbo can differ for the following reasons\+:


\begin{DoxyItemize}
\item The S\+S\+E/\+S\+S\+E2 floating point D\+CT implementation in libjpeg-\/turbo is ever so slightly more accurate than the implementation in libjpeg v6b, but not by any amount perceptible to human vision (generally in the range of 0.\+01 to 0.\+08 dB gain in P\+N\+SR.)
\item When not using the S\+I\+MD extensions, libjpeg-\/turbo uses the more accurate (and slightly faster) floating point I\+D\+CT algorithm introduced in libjpeg v8a as opposed to the algorithm used in libjpeg v6b. It should be noted, however, that this algorithm basically brings the accuracy of the floating point I\+D\+CT in line with the accuracy of the slow integer I\+D\+CT. The floating point D\+C\+T/\+I\+D\+CT algorithms are mainly a legacy feature, and they do not produce significantly more accuracy than the slow integer algorithms (to put numbers on this, the typical difference in P\+N\+SR between the two algorithms is less than 0.\+10 dB, whereas changing the quality level by 1 in the upper range of the quality scale is typically more like a 1.\+0 dB difference.)
\item If the floating point algorithms in libjpeg-\/turbo are not implemented using S\+I\+MD instructions on a particular platform, then the accuracy of the floating point D\+C\+T/\+I\+D\+CT can depend on the compiler settings.
\end{DoxyItemize}

While libjpeg-\/turbo does emulate the libjpeg v8 A\+P\+I/\+A\+BI, under the hood it is still using the same algorithms as libjpeg v6b, so there are several specific cases in which libjpeg-\/turbo cannot be expected to produce the same output as libjpeg v8\+:


\begin{DoxyItemize}
\item When decompressing using scaling factors of 1/2 and 1/4, because libjpeg v8 implements those scaling algorithms differently than libjpeg v6b does, and libjpeg-\/turbo\textquotesingle{}s S\+I\+MD extensions are based on the libjpeg v6b behavior.
\item When using chrominance subsampling, because libjpeg v8 implements this with its D\+C\+T/\+I\+D\+CT scaling algorithms rather than with a separate downsampling/upsampling algorithm. In our testing, the subsampled/upsampled output of libjpeg v8 is less accurate than that of libjpeg v6b for this reason.
\item When decompressing using a scaling factor $>$ 1 and merged (A\+KA \char`\"{}non-\/fancy\char`\"{} or \char`\"{}non-\/smooth\char`\"{}) chrominance upsampling, because libjpeg v8 does not support merged upsampling with scaling factors $>$ 1.
\end{DoxyItemize}

\section*{Performance Pitfalls }

\subsection*{Restart Markers }

The optimized Huffman decoder in libjpeg-\/turbo does not handle restart markers in a way that makes the rest of the libjpeg infrastructure happy, so it is necessary to use the slow Huffman decoder when decompressing a J\+P\+EG image that has restart markers. This can cause the decompression performance to drop by as much as 20\%, but the performance will still be much greater than that of libjpeg. Many consumer packages, such as Photoshop, use restart markers when generating J\+P\+EG images, so images generated by those programs will experience this issue.

\subsection*{Fast Integer Forward D\+CT at High Quality Levels }

The algorithm used by the S\+I\+M\+D-\/accelerated quantization function cannot produce correct results whenever the fast integer forward D\+CT is used along with a J\+P\+EG quality of 98-\/100. Thus, libjpeg-\/turbo must use the non-\/\+S\+I\+MD quantization function in those cases. This causes performance to drop by as much as 40\%. It is therefore strongly advised that you use the slow integer forward D\+CT whenever encoding images with a J\+P\+EG quality of 98 or higher.

\section*{Memory Debugger Pitfalls }

Valgrind and Memory Sanitizer (M\+San) can generate false positives (specifically, incorrect reports of uninitialized memory accesses) when used with libjpeg-\/turbo\textquotesingle{}s S\+I\+MD extensions. It is generally recommended that the S\+I\+MD extensions be disabled, either by passing an argument of {\ttfamily -\/\+D\+W\+I\+T\+H\+\_\+\+S\+I\+MD=0} to {\ttfamily cmake} when configuring the build or by setting the environment variable {\ttfamily J\+S\+I\+M\+D\+\_\+\+F\+O\+R\+C\+E\+N\+O\+NE} to {\ttfamily 1} at run time, when testing libjpeg-\/turbo with Valgrind, M\+San, or other memory debuggers. 